\name{compile.nls}
\alias{compile.nls}
\alias{ccnls}

\title{Compiled code solver for nonlinear least squares problems}
\description{
  \code{compile.nls} generates compiled code 
  for nonlinear least squares minimization. It is to be be solved with function
  \code{ccnls} that provides a compiled code 
  variant of function \link{nls.lm} from the R-package \code{minpack.lm}.
  
}
\usage{
 compile.nls (func, jacfunc = NULL, data, par = NULL,
     declaration = character(), includes = character(), language = "F95", ...)

 ccnls(fn, data, par, lower = NULL, upper = NULL, jac = NULL, 
     control = nls.lm.control(), dllname = NULL, initfunc = NULL, 
     rpar = NULL, ipar = NULL)

}
\arguments{
  \item{par }{Initial values for the parameters to be optimized over (\code{ccnls})
   or a vector that contains the names of the parameters. These names will then be
   known in the compiled codes.
  }
  \item{fn }{A compiled subroutine that defines the residuals to be minimized, e.g. as generated by \code{compile.nls} or 
    a character string giving the name of a compiled subroutine in a 
    dynamically loaded shared library. 
  }
  \item{func }{A character vector with F95, Fortran, or C code, without 
    declarations, that specifies the least squares function. 
    The subroutine will be defined as \code{func(n, ndat, x, f, rpar, ipar)},
     where \code{x} is the vector of parameters over which minimization is 
     to take place, \code{n} is the number of parameters, \code{ndat} is the 
     number of data values, \code{rpar} and 
     \code{ipar} are vectors of double and integer values, as passed with the 
     arguments of the same name. The result, a vector of length \code{ndat} 
     should contain the residuals with respect to the data and be put in \code{f}.
   }
  \item{jac }{A compiled subroutine that specifies the jacobian for the 
    nls method, e.g. as generated by \code{compile.nls}. 
    If it is \code{NULL}, a finite-difference approximation will be used.
  }
  \item{jacfunc }{A character vector with F95, Fortran, or C code, without 
    declarations, that specifies the jacobian of the function whose least-squares solution has to be found. 

    The subroutine will be defined as \code{jacfunc(n, ndat, ldfjac, x, df, rpar, ipar )},
    where \code{x} is the vector of parameters over which minimization is 
     to take place, \code{n} is the number of parameters, \code{ndat} is the 
     number of data values, \code{ldfjac} is the leading dimension of the jacobian (=\code{ndat}),
     \code{rpar} and \code{ipar} are vectors of double and integer values, as passed with the
     arguments of the same name. The result, a matrix of dimension (\code{ldfjac, n)} 
     (language = Fortran, F95) or a vector of length \code{ldfjac*n}  (language = C) 
     should be put in \code{df}.
   }
   \item{data }{A dataset with the same structure as will be used during run-time. 
     It should have named columns, and these names will be used to define global 
     variables (vectors) that will be given the actual data values upon run time.
     The names of these variables are available in the subroutines func and jacfunc.
   }
   \item{lower, upper }{Bounds on the variables. 
   }
   \item{control }{A list of control parameters. See "Details" of \link{nls.lm.control}.
   }
  \item{dllname }{A string giving the name of the shared library (without extension) 
   that contains all the compiled function or subroutine definitions referred to in \code{fn} and \code{jac}.
  }
  \item{initfunc }{The name of the initialisation function (which initialises values of data), 
    as provided in "dllname". Will be generated with \code{compile.nls} }
   \item{rpar, ipar }{double and integer vector to be passed upon running the model.
  }
  \item{declaration }{Text that enters the declaration section in each function.
  }
  \item{includes }{Code that comes before the functions.
  }
  \item{language }{A character vector that specifies the source code; one of c("F95", "Fortran", "C"); defaults to "F95".
  }
  \item{...}{optional arguments to the generic function (not used).
  }
}
\value{
  \code{compile.nls} returns an object of class \code{CFunc} or 
  \code{CFuncList}, as generated by \link{cfunction} from the package  \code{inline}. 

  
  \code{ccnls} returns an object of class \code{ccnls} and \code{nls.lm}
  
  Function \link{ccfunc} can be used to estimate function values.
}  

\details{

The compiled functions that are generated by \code{compile.nls} is defined as:

 \code{func(n, ndat, x, f, rpar, ipar) }

 \code{jacfunc(n, ndat, ldfjac, x, df, rpar, ipar) }
 
In case Fortran or F95 is used, \code{n, ndat, ldfjac} are an integer value,

\code{ipar} and \code{rpar} are an integer vector, and double vector, that can be 
used to pass values at runtime.  

\code{x}, and \code{f} are a double vector of length \code{n}.

\code{df} is a vector of dimension \code{n, ldfjac}, where \code{ldfjac} equals \code{ndat}.

In case C is used all are pointers. 

The values of \code{df} are set to 0 at the beginning of the subroutine.

The user needs to specify \code{f, df}, based on \code{x}

}

\note{
The implementation of \code{ccnls} is based on \code{nls.lm} which is a modified 
levenberg-marquardt algorithm from the R-package \code{minpack.lm}. 
Results from \code{ccnls} will therefore deviate from the results of \code{nls}.

It is not possible to specify \code{parms} here (this was deemed to be too
confusing with the \code{par} argument. In case constants need to be passed
upon runtime, \code{rpar} should be used.
}
\examples{
\dontrun{
## -------------------------------------------------------------------------
## First examples nls
## -------------------------------------------------------------------------

DNase1 <- subset(DNase, Run == 1)

fm2DNase1 <- nls(density ~ 1/(1 + exp((xmid - log(conc))/scal)),
                 data = DNase1,
                 start = list(xmid = 0, scal = 1))
summary(fm2DNase1)

# compile it such that the compiler knows the names of the par to be solved for 
# and the names of the data; the values of par and data can differ during
# the actual application; the ordering of parameters and datacolumns should
# stay the same.

# F95 works with vectors
head (DNase1 [, -1])      # names conc, density

f1 = "f = density - 1.0/(1.d0 + dexp((xmid - dlog(conc))/scal))"
ccDNase <- compile.nls(func = f1, par = c(xmid = 0, scal = 1), data = DNase1[,-1])  
code(ccDNase)

# for C you need to write a loop:
ccDNase.C <- compile.nls(func = '
 int i; 
 for (i = 0; i < *ndat; i++)
   f[i] = density[i] - 1.0/(1.0 + exp((xmid - log(conc[i]))/scal));',
 par = c(xmid = 0, scal = 1), 
 data = DNase1[,-1], language = "C")  

fm2DNase2 <- ccnls(fn = ccDNase, data = DNase1[,-1], 
  par = c(xmid = 0, scal = 1))

summary(fm2DNase2)


for ( i in 1:11)
  print(ccnls(fn = ccDNase, par = c(xmid = 0, scal = 1),
    data = subset(DNase, Run == i)[, -1])$par)

# ---------------------------------------------------------------------------
# example from minpack.lm
# ---------------------------------------------------------------------------

## simulated data, with noise  
x <- seq(0, 5, length = 100)
getPred <- function(parS, xx) parS$a * exp(xx * parS$b) + parS$c 
pp <- list(a = 9, b = -1, c = 6) 
simDNoisy <- getPred(pp, x) + rnorm(length(x), sd = .1)

plot(x, simDNoisy, main = "data")
residFun <- function(p, observed, xx) observed - getPred(p,xx)

## starting values for parameters  
parStart <- list(a = 3, b = -.001, c = 1)

## perform fit 
nls.out <- nls.lm(par=parStart, fn = residFun, observed = simDNoisy,
   xx = x, control = nls.lm.control(nprint=1))

## in compiled code note: cannot use x as name of data
Data <- cbind(xx = x, y = simDNoisy)
f.95 <- " f = y - a * exp(xx * b) - c "
cf.95 <- compile.nls (func = f.95, par = parStart, data = Data)
ccnls.out <- ccnls(par = parStart, fn = cf.95, data = Data, 
  control = nls.lm.control(nprint=1))
coef(ccnls.out)
}
}
\author{
  Karline Soetaert <karline.soetaert@nioz.nl>

  Function \code{ccnls} has copied significant parts of the R-function \link{nls.lm},
  from the package \code{minpack.lm} and from the C-code in this package.
  
}

\keyword{ utilities }